---
title: "macro_data_cleaning"
format: html
editor: visual
---

## To-do

-   Re-do the relative female lfp - check you know both male and female lfp in every case, then calculate, standardise, then interpolate

-   Also standardise the educational advantage indicators - think about what it does

## Initial setup

```{r packages}
#| warning: false
#| message: false

# General functionality
library(tidyverse)

# For importing the data
library(sjmisc)
library(haven)
library(janitor)
library(countrycode)
library(stringr)

#for pulling the data from the websites
library(WDI)
library(eurostat)
library(OECD)
library(jsonlite)

# load file paths
source("config.R")
```

## ILO Labour Force Participation Rate

I'm pulling the national survey results with ILO modeled estimates filling them in.

```{r}
lf_rate_ilo_raw <- read.csv("https://rplumber.ilo.org/data/indicator/?id=EAP_DWAP_SEX_AGE_RT_A&lang=en&type=label&format=.csv&channel=ilostat&title=labour-force-participation-rate-by-sex-and-age-annual")

lf_rate_ilo <- lf_rate_ilo_raw |> 
  tibble() |> 
  mutate(country = ref_area.label,
         indicator = indicator.label,
         source = source.label,
         age = classif1.label,
         sex = sex.label) |>
  mutate(
    country = case_when(
    country == "United Kingdom of Great Britain and Northern Ireland" ~ "United Kingdom",
    country == "United States of America" ~ "United States",
    country == "Republic of Moldova" ~ "Moldova",
    country == "Russian Federation" ~ "Russia",
    TRUE ~ country  # Keep all other values as they are
  )) |> 
  # pulling my countries
  filter(country %in% unique(micro_clean$country)) |> 
  # pulling appropriate age band
  filter(classif1.label == "Age (Youth, adults): 15-64") |> 
  # filtering out total lfp
  filter(sex.label != "Total") |> 
  select(country, indicator, sex, age, time, obs_value, source) |> 
  arrange(country, sex, age, time)

lf_rate_ilo_modeled_raw <- read.csv("https://rplumber.ilo.org/data/indicator/?id=EAP_2WAP_SEX_AGE_RT_A&lang=en&type=label&format=.csv&channel=ilostat&title=labour-force-participation-rate-by-sex-and-age-ilo-modelled-estimates-annual")

lf_rate_ilo_modeled <- lf_rate_ilo_modeled_raw |> 
  tibble() |> 
  mutate(country = ref_area.label,
         indicator = indicator.label,
         source = source.label,
         age = classif1.label,
         sex = sex.label) |>
  mutate(
    country = case_when(
    country == "United Kingdom of Great Britain and Northern Ireland" ~ "United Kingdom",
    country == "United States of America" ~ "United States",
    country == "Republic of Moldova" ~ "Moldova",
    country == "Russian Federation" ~ "Russia",
    TRUE ~ country  # Keep all other values as they are
  )) |>
  # pulling my countries
  filter(country %in% unique(micro_clean$country)) |> 
  # pulling appropriate age band
  filter(classif1.label == "Age (Youth, adults): 15-64") |> 
  # filtering out total lfp
  filter(sex.label != "Total") |> 
  select(country, indicator, sex, age, time, obs_value, source) |> 
  arrange(country, sex, age, time)

# Now I have to fill in the gaps with the modelled estimates
# filled in the gaps with modelled estimates

lf_rate_combined <- lf_rate_ilo |>
  bind_rows(
    lf_rate_ilo_modeled |>
      anti_join(lf_rate_ilo, by = c("country", "time"))
  ) |> 
  arrange(country, sex, age, time)

# remove intermediates
rm(lf_rate_ilo_raw)
rm(lf_rate_ilo_modeled_raw)
rm(lf_rate_ilo)
rm(lf_rate_ilo_modeled)
```

## ILO unemployment by education

```{r unemployment-by-education}
unemployment_educ_raw <- read.csv("https://rplumber.ilo.org/data/indicator/?id=UNE_DEAP_SEX_AGE_EDU_RT_A&sex=SEX_T+SEX_M+SEX_F&classif1=AGE_YTHADULT_Y15-64&classif2=EDU_ISCED11_TOTAL+EDU_ISCED11_X+EDU_ISCED11_0+EDU_ISCED11_1+EDU_ISCED11_2+EDU_ISCED11_3+EDU_ISCED11_4+EDU_ISCED11_5+EDU_ISCED11_6+EDU_ISCED11_7+EDU_ISCED11_8+EDU_ISCED11_9&timefrom=1970&timeto=2024&type=label&format=.csv")

unemployment_educ <- unemployment_educ_raw |> 
  tibble() |> 
  mutate(country = ref_area.label,
         indicator = indicator.label,
         source = source.label,
         age = classif1.label,
         educ = classif2.label,
         sex = sex.label) |> 
  mutate(
    country = case_when(
    country == "United Kingdom of Great Britain and Northern Ireland" ~ "United Kingdom",
    country == "United States of America" ~ "United States",
    country == "Republic of Moldova" ~ "Moldova",
    country == "Russian Federation" ~ "Russia",
    TRUE ~ country  # Keep all other values as they are
  )) |> 
  # pulling my countries
  filter(country %in% unique(micro_clean$country)) |> 
  select(country, indicator, sex, age, educ, time, obs_value, obs_status.label, source)

unemployment_index <- unemployment_educ |> 
  
  # recoding educ
  mutate(educ = case_when(
    str_detect(educ, "X\\.") ~ "-1",  # If it contains "x."
    TRUE ~ str_extract(educ, "(?<=\\): )\\d+")  # Otherwise extract the number
  )) |>
  
  # grouping educ
  mutate(educ_group = case_when(
    educ < 3 ~ "below upper-secondary",
    educ > 4 ~ "tertiary",
    TRUE ~ "upper-secondary"
  )) |> 

  # just total gender
  filter(sex == "Total") |> 

  # just specific education categories
  filter(educ != "Education (ISCED-11): Total")

# Calculate upper secondary mean
upper_sec_means <- unemployment_index |>
  filter(educ_group == "upper-secondary") |>
  group_by(country, time) |>
  summarise(upper_sec_mean = mean(obs_value))

below_upper_sec_means <- unemployment_index |>
  filter(educ_group == "below upper-secondary") |>
  group_by(country, time) |>
  summarise(below_upper_sec_mean = mean(obs_value))
  
# Join and calculate index
unemployment_index <- unemployment_index |>
  group_by(country, time, educ_group, sex, source, indicator) |> 
  summarise(mean_value = mean(obs_value)) |>
  ungroup() |> 
  left_join(upper_sec_means, by = join_by(country, time)) |>
  left_join(below_upper_sec_means, by = join_by(country, time)) |>
  mutate(upper_sec_index = mean_value / upper_sec_mean * 100,
         below_upper_sec_index = mean_value / below_upper_sec_mean * 100)

# unloading intermediate dfs
rm(upper_sec_means)
rm(bellow_upper_sec_means)

rm(unemployment_educ_raw)
rm(unemployment_educ)
```

## ILO earnings advantage

```{r earnings-advantage}
earnings_educ_raw <- read.csv("https://rplumber.ilo.org/data/indicator/?id=EAR_4MTH_SEX_EDU_CUR_NB_A&sex=SEX_T+SEX_M+SEX_F&classif1=EDU_ISCED11_TOTAL+EDU_ISCED11_X+EDU_ISCED11_0+EDU_ISCED11_1+EDU_ISCED11_2+EDU_ISCED11_3+EDU_ISCED11_4+EDU_ISCED11_5+EDU_ISCED11_6+EDU_ISCED11_7+EDU_ISCED11_8&timefrom=1989&timeto=2024&type=label&format=.csv")

earnings_educ <- earnings_educ_raw |> 
  tibble() |> 
  mutate(country = ref_area.label,
         indicator = indicator.label,
         source = source.label,
         educ = classif1.label,
         currency = classif2.label,
         sex = sex.label) |> 
  mutate(
    country = case_when(
    country == "United Kingdom of Great Britain and Northern Ireland" ~ "United Kingdom",
    country == "United States of America" ~ "United States",
    country == "Republic of Moldova" ~ "Moldova",
    country == "Russian Federation" ~ "Russia",
    TRUE ~ country  # Keep all other values as they are
  )) |> 
  # pulling my countries
  filter(country %in% unique(micro_clean$country)) |> 
  select(country, indicator, sex, educ, currency, time, obs_value, source, note_indicator.label) |> 
  
  # just 2021 ppp $
  filter(currency == "Currency: 2021 PPP $") |>
  
  # just total gender
  filter(sex == "Total") |> 
  
  # just specific education categories
  filter(educ != "Education (ISCED-11): Total") |> 
  
  # recoding the educ
  mutate(educ = case_when(
    str_detect(educ, "X\\.") ~ "-1",  # If it contains "x."
    TRUE ~ str_extract(educ, "(?<=\\): )\\d+")  # Otherwise extract the number
  )) |> 
  
  # breaks in series
  mutate(break_in_series = case_when(
    str_detect(note_indicator.label, "Break in series") ~ 1,
    TRUE ~ 0
  ))

relative_earnings <-  earnings_educ |> 
  
  # Creating educational groups
  mutate(educ_group = case_when(
    educ < 3 ~ "below upper-secondary",
    educ > 4 ~ "tertiary",
    TRUE ~ "upper-secondary"
  ))

# Calculate upper secondary mean
upper_sec_means <- relative_earnings |>
  filter(educ_group == "upper-secondary") |>
  group_by(country, time) |>
  summarise(upper_sec_mean = mean(obs_value))

below_upper_sec_means <- relative_earnings |>
  filter(educ_group == "below upper-secondary") |>
  group_by(country, time) |>
  summarise(below_upper_sec_mean = mean(obs_value))
  
# Join and calculate index
relative_earnings_index <- relative_earnings |>
  group_by(country, time, educ_group, sex, break_in_series, source, currency, indicator) |> 
  summarise(mean_value = mean(obs_value)) |>
  ungroup() |> 
  left_join(upper_sec_means, by = join_by(country, time)) |>
  left_join(below_upper_sec_means, by = join_by(country, time)) |>
  mutate(upper_sec_index = mean_value / upper_sec_mean * 100,
         below_upper_sec_index = mean_value / below_upper_sec_mean * 100)

# removing intermediate dfs
rm(upper_sec_means)
rm(below_upper_sec_means)

rm(relative_earnings)
rm(earnings_educ)
rm(earnings_educ_raw)
```

## Combining all the ILO measures

```{r economy-indicators}
# With unemployment - more than 100 means disadvantage from education
macro_indicators <- unemployment_index |> 
  select(-mean_value, -upper_sec_mean, -below_upper_sec_mean) |> 
  filter(educ_group == "tertiary" | educ_group == "upper-secondary") |> 
  pivot_longer(
    cols = c(upper_sec_index, below_upper_sec_index),
    names_to = "index",
    values_to = "index_value"
  ) |>
  mutate(index = str_remove(index, "_index")) |> 
  filter((educ_group == "upper-secondary" & index != "upper_sec") | (educ_group == "tertiary" & index != "below_upper_sec")) |>
  
  # now making the averages
  group_by(country, time, sex) |> 
  summarise(educ_unemployment_advantage = mean(index_value)) |> 
  ungroup()

# with earnings - higher means greater advantage
macro_indicators <- 
  full_join(macro_indicators,
  
  # constructing the other measure
  relative_earnings_index |>           
  select(-mean_value, -upper_sec_mean, -below_upper_sec_mean) |> 
  filter(educ_group == "tertiary" | educ_group == "upper-secondary") |> 
  pivot_longer(
    cols = c(upper_sec_index, below_upper_sec_index),
    names_to = "index",
    values_to = "index_value"
  ) |>
  mutate(index = str_remove(index, "_index")) |> 
  filter((educ_group == "upper-secondary" & index != "upper_sec") | (educ_group == "tertiary" & index != "below_upper_sec")) |>
  
  # now making the averages
  group_by(country, time, sex) |> 
  summarise(educ_earnings_advantage = mean(index_value)) |> 
  ungroup(),
  
  by = join_by(country, time, sex)
  )

# adding female labour force participation

macro_indicators <- 
  full_join(macro_indicators,
    lf_rate_combined |> 
      filter(sex == "Female") |> 
      select(-sex, -age, - source, - indicator) |> 
      rename(female_lfp_rate = obs_value),
    by = join_by(country, time)
  ) |>
  select(-sex) |> 
  arrange(country, time)
  
  # adding men
macro_indicators <-
  full_join(macro_indicators,
    lf_rate_combined |> 
      filter(sex == "Male") |> 
      select(-sex, -age, - source, - indicator) |> 
      rename(male_lfp_rate = obs_value),
    by = join_by(country, time)
  )

# removing intermediate dfs
rm(lf_rate_combined)
rm(relative_earnings_index)
rm(unemployment_index)
```

## Value measures

I learned a new thing here - you can rename columns directly inside select (newname = oldname).

I load in the IVS (EVS + WVS) full time-series into R and pick out variables of interest.

```{r IVS}
# load in integrated values survey (created with a stata script from GESIS)
gender_role_attitudes_raw <- 
  read_dta(paste0(data_path, "/macro/Integrated_values_surveys_1981-2022.dta")) |> 
  clean_names("snake") |> 
  
  # Variable selection
  select(
    # respid
    respid = s007_01,
    
    # details about the study and country
    studyno,
    time = s020, # study year
    s009,
    
    # weights
    s017,
    s018,
    s019,
    pwght,
    
    # indicators
    
    # gender role attitudes
    housewife = d057, # Being a housewife just as fulfilling
    equal_contribution = d058, # Husband and wife should both contribute to income
    men_political_leader = d059, # Men make better political leaders than women do
    university_for_boys = d060, # University is more important for a boy than for a girl
    preschool_suffer = d061, # Pre-school child suffers with working mother
    women_want_home = d062, # Women want a home and children
    women_job_indep = d063, # Job best way for women to be independent (4 categories)
    
    # family diversity acceptance
    child_needs_mum_dad = d018, # Child needs a home with father and mother
    woman_children_fulfilled = d019, # A woman has to have children to be fulfilled
    fathers_good_with_children = d064, # Fathers are well suited for looking after children
    
    # interesting
    marriage_outdated = d022 # Marriage is an out-dated institution
  ) |> 
  
  # GB and North Ireland are separated, I'm going to squish them together
  mutate(s009 = case_when(
    s009 == "NIR" ~ "GB",
    str_detect(s009, "^GB-") ~ "GB",
    TRUE ~ s009
  )) |> 
  
  # getting country names
  mutate(
    country = countrycode(s009, "iso2c", "country.name"),
    .before = everything()
  ) |> 
  
  # filter for countries in my analysis
  filter(country %in% unique(micro_clean$country))
```

#### Family diversity acceptance

```{r family-diversity-acceptance}
family_diversity_acceptance <- 
  gender_role_attitudes_raw |> 
  
  # need to reverse scales to get desired interpretation
  mutate(
    rev_child_needs_mum_dad = case_when(
      child_needs_mum_dad == 0 ~ 1,
      child_needs_mum_dad == 1 ~ 0,
      TRUE ~ NA
    ),
    
    rev_woman_children_fulfilled = case_when(
      woman_children_fulfilled == 0 ~ 1,
      woman_children_fulfilled == 1 ~ 0,
      TRUE ~ NA
    ),
    
    rev_fathers_good_with_children = if_else(
      !is.na(fathers_good_with_children),
      5 - fathers_good_with_children,
      NA
    )
  ) |> 
  
  # naive assumption missing person weight is equal to 1
  mutate(perswgt = if_else(is.na(pwght), 1, pwght)) |> 
  
  # obtain weighted mean attitudes within country and year
  group_by(country,time) |> 
  summarise(
    mean_child_needs_mum_dad = weighted.mean(rev_child_needs_mum_dad, perswgt, na.rm = TRUE),
    mean_woman_children_fulfilled = weighted.mean(rev_woman_children_fulfilled, perswgt, na.rm = TRUE),
    mean_fathers_children = weighted.mean(rev_fathers_good_with_children, perswgt, na.rm = TRUE)
  ) |> 
  
  ungroup() |> 
  
  # standardisation
  mutate(
    std_child_needs_mum_dad = scale(mean_child_needs_mum_dad)[,1],
    std_woman_children_fulfilled = scale(mean_woman_children_fulfilled)[,1],
    std_fathers_children = scale(mean_fathers_children)[,1]
  ) |> 
  
  # summing into an index, filled proportionally if 1 of the items was missing
  mutate(
    n_items = rowSums(!is.na(pick(starts_with("std")))),
    
    family_diversity_acceptance = case_when(
      n_items == 3 ~ std_child_needs_mum_dad + std_woman_children_fulfilled + std_fathers_children,  # complete: use sum
      n_items == 2 ~ rowSums(pick(starts_with("std")), na.rm = TRUE) * (3/2),  # prorate
      TRUE ~ NA  # 0 or 1 items: set to missing
    )
  ) |> 
  
  # clean up helper variable and extra rows
  select(-n_items, -starts_with("mean"), -starts_with("std")) |> 
  filter(!is.na(family_diversity_acceptance))
```

#### Gender role attitudes

```{r gender role attitudes}
# these go from traditional to progressive
gender_roles <- 
  gender_role_attitudes_raw |> 
  
  # naive assumption missing person weight is equal to 1
  mutate(perswgt = if_else(is.na(pwght), 1, pwght)) |>
  
  # weighted means of index components
  group_by(country, time) |> 
  summarise(
    mean_housewife_fulfilling = mean(housewife, perswgt, na.rm = TRUE),
    mean_political_leader = mean(men_political_leader, perswgt, na.rm = TRUE),
    mean_university = mean(university_for_boys, perswgt, na.rm = TRUE),
    mean_women_want_home = mean(women_want_home, na.rm = TRUE)
  ) |> 
  
  ungroup() |> 
  
  # standardise
  mutate(across(
    .cols = starts_with("mean_"),
    .fns = ~scale(.)[,1],
    .names = "{str_replace(.col, 'mean_', 'std_')}"
  )) |> 
  
  # if 1 is missing I fill in the scale proportionally
  mutate(
    n_items = rowSums(!is.na(pick(starts_with("std")))),
    gender_roles = case_when(
      n_items == 4 ~ std_housewife_fulfilling + std_political_leader + std_university + std_women_want_home,  # complete: use sum
      n_items == 3 ~ rowSums(pick(starts_with("std")), na.rm = TRUE) * (4/3),  # prorate
      TRUE ~ NA  # 0 or 1 or 2 items: set to missing
    )
  ) |>
  # clean up helper variable and extra rows
  select(-n_items, -starts_with("mean"), -starts_with("std")) |> 
  filter(!is.na(gender_roles))
```

## Finishing touches - interpolation of missing values

Note for the future - the approach of other studies is to

1\) interpolate the values from one source

2\) then add any missing gaps with other source BUT

3\) do so through a linear model with country-intercepts and full-information maximum likelihood estimation in order to correct for scale differences (e. g. estimate the prediction of what the value would be in the original data source given the information from the other data source (e. g. the other source systematically undervalues the variable compared to the first source))

```{r export-to-analysis}
# adding macro_indicators
macro_indicators_interpolated <- macro_indicators |> 
  full_join(family_diversity_acceptance, by = join_by(country, time)) |> 
  full_join(gender_roles, by = join_by(country, time)) |> 
  
  #standardise the economic vars
  mutate(
    relative_lfp = female_lfp_rate/male_lfp_rate,
    
    std_relative_lfp = scale(relative_lfp)[,1],
    std_educ_unemployment_advantage = scale(educ_unemployment_advantage)[,1],
    std_educ_earnings_advantage = scale(educ_earnings_advantage)[,1],
  ) |> 
  
  select(-relative_lfp) |> 
  
  # fill in rows for all countries
  group_by(country) |> 
  complete(time = min(time):2024) |> 
  
  # interpolation between timepoints
  mutate(
    std_relative_lfp = approx(time, std_relative_lfp, xout = time, rule =1)$y,
    
    std_educ_unemployment_advantage = if(sum(!is.na(std_educ_unemployment_advantage)) >= 2) {
      approx(time, std_educ_unemployment_advantage, xout = time, rule = 1)$y
    } else {
      std_educ_unemployment_advantage
    },
    
    std_educ_earnings_advantage = if(sum(!is.na(std_educ_earnings_advantage)) >= 2) {
      approx(time, std_educ_earnings_advantage, xout = time, rule = 1)$y
    } else {
      std_educ_earnings_advantage
    },
    
    
    family_diversity_acceptance = if(sum(!is.na(family_diversity_acceptance)) >= 2) {
      
      approx(time, family_diversity_acceptance, xout = time, rule = 1)$y
    } else {
      family_diversity_acceptance
    },
    
    gender_roles = if(sum(!is.na(gender_roles)) >= 2) {
      
      approx(time, gender_roles, xout = time, rule = 1)$y
    } else {
      gender_roles
    },
    )|> 
  ungroup()
```

Finally, just remove the intermediate dfs.

```{r removal}
rm(macro_indicators)
rm(gender_role_attitudes_raw)
rm(gender_roles)
rm(family_diversity_acceptance)
```
